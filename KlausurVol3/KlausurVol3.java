

public class KlausurVol3{
    public static void main(String[] args){

        Arrays ownArray = new Arrays();

        ownArray.arrayInt(5);
        ownArray.arrayInt(55);
        System.out.println("arrayInt: " + ownArray.findArrayInt(5));
        System.out.println("arrayInt: " + ownArray.findArrayInt(54));

        ownArray.hashedArray(100);
        ownArray.hashedArray(295);
        System.out.println("hashedArray: " + ownArray.findHashedArray(100));
        System.out.println("hashedArray: " + ownArray.findHashedArray(294));

        for (int i = 0; i <= 100; i++){
            ownArray.arrayInt(i);
        }
        
        System.out.println("arrayInt: " + ownArray.findArrayInt(100));

        for(int i = 0; i<= 100; i++){
            ownArray.hashedArray(i);
        }
        System.out.println("hashedArray: " + ownArray.findHashedArray(100));

        System.out.println("intArray(bench): " + ownArray.benchmarkInt(100));
        System.out.println("hashedArray(bench): " + ownArray.benchmarkH(100));
        
        int[] array = {5,4,6,9,8,1,2,3,5,7,8,5,2,1,3,9,9};
        Sorting sorter = new Sorting(array);
        
        for(int g: sorter.bubblesort(array)) {
        	System.out.print(g + ",");
        }
        
    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Arrays (eindimensional und zweidimensional)    /////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

   // See Arrays.java 

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Sortieralgorithmen inkl Implementation von Bubblesort, SelectionSort.   ////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  MergeSort/QuickSort beschreiben.    ////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Sortierverfahren hinsichtlich der Laufzeit, Speicherbedarf und Stabilität (letzteres erläutere ich in kommender Stunde) bewerten.   ////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  ADTs (einfach verkettete Liste, Schlange, Queue, Stack, binärer Baum, Set) beschreiben und Implementieren (gemäß unserer Übungsaufgaben)   /
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Auswahl passender ADTs auf konkrete Anwendungsfälle (Rangierbahnhof, Familienbaum, ToDo-Liste, Klammerausdrücke).   ////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Inorder/Postorder/Preorder händisch darstellen. ////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  UML-Klassendiagramme mit Vererbung und Assoziation entwerfen und zur Modellierung nutzen.   ////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}